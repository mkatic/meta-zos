From 348cae864bf5caddd59267cadde7c1a48adf61ac Mon Sep 17 00:00:00 2001
From: Marko Katic <dromede.gmail.com>
Date: Tue, 15 Nov 2011 13:42:31 +0100
Subject: [PATCH 01/15] Pxafb: A different way of allocating fb memory.

This patch places the framebuffer in 2 consecutive
section maps, thus reducing TLB trashing. The first section
maps into 1Mib of main ram and the second section maps the internal
256 Kib sram.
---
 arch/arm/mach-pxa/spitz.c |    9 ++++++
 drivers/video/fbmem.c     |    9 ++++++
 drivers/video/pxafb.c     |   62 +++++++++++++++++++++++++++++++++++++++-----
 drivers/video/pxafb.h     |    3 ++
 include/linux/fb.h        |    2 +
 5 files changed, 78 insertions(+), 7 deletions(-)

diff --git a/arch/arm/mach-pxa/spitz.c b/arch/arm/mach-pxa/spitz.c
index 953a919..992f283 100644
--- a/arch/arm/mach-pxa/spitz.c
+++ b/arch/arm/mach-pxa/spitz.c
@@ -31,7 +31,9 @@
 #include <linux/regulator/machine.h>
 #include <linux/io.h>
 #include <linux/module.h>
+#include <linux/memblock.h>
 
+#include <asm/sizes.h>
 #include <asm/setup.h>
 #include <asm/mach-types.h>
 #include <asm/mach/arch.h>
@@ -980,9 +982,15 @@ static void __init spitz_fixup(struct tag *tags, char **cmdline,
 	mi->bank[0].size = (64*1024*1024);
 }
 
+static void __init Cxx0_reserve_fbmem (void) {
+
+	memblock_reserve(0xA3E00000, SZ_1M);
+}
+
 #ifdef CONFIG_MACH_SPITZ
 MACHINE_START(SPITZ, "SHARP Spitz")
 	.fixup		= spitz_fixup,
+	.reserve	= Cxx0_reserve_fbmem,
 	.map_io		= pxa27x_map_io,
 	.init_irq	= pxa27x_init_irq,
 	.handle_irq	= pxa27x_handle_irq,
@@ -1005,6 +1013,7 @@ MACHINE_END
 #ifdef CONFIG_MACH_AKITA
 MACHINE_START(AKITA, "SHARP Akita")
 	.fixup		= spitz_fixup,
+	.reserve	= Cxx0_reserve_fbmem,
 	.map_io		= pxa27x_map_io,
 	.init_irq	= pxa27x_init_irq,
 	.handle_irq	= pxa27x_handle_irq,
diff --git a/drivers/video/fbmem.c b/drivers/video/fbmem.c
index ad93629..48e3fab 100644
--- a/drivers/video/fbmem.c
+++ b/drivers/video/fbmem.c
@@ -1065,6 +1065,15 @@ static long do_fb_ioctl(struct fb_info *info, unsigned int cmd,
 	long ret = 0;
 
 	switch (cmd) {
+
+	case FBIOGET_VRAM_START_ADDRESS:
+		ret = (unsigned long)info->screen_base;
+		break;
+
+	case FBIOGET_VRAM_END_ADDRESS:
+		ret = (unsigned long)info->screen_base + (1024 * 1024) + (1024 * 256);
+		break;
+
 	case FBIOGET_VSCREENINFO:
 		if (!lock_fb_info(info))
 			return -ENODEV;
diff --git a/drivers/video/pxafb.c b/drivers/video/pxafb.c
index 1d1e4f1..dee1850 100644
--- a/drivers/video/pxafb.c
+++ b/drivers/video/pxafb.c
@@ -54,11 +54,19 @@
 #include <linux/mutex.h>
 #include <linux/kthread.h>
 #include <linux/freezer.h>
+#include <linux/io.h>
+#include <linux/vmalloc.h>
 
 #include <mach/hardware.h>
 #include <asm/io.h>
 #include <asm/irq.h>
 #include <asm/div64.h>
+#include <asm/sizes.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <asm/mach/map.h>
+#include <asm/cacheflush.h>
+#include <asm/tlbflush.h>
 #include <mach/bitfield.h>
 #include <mach/pxafb.h>
 
@@ -85,6 +93,11 @@ static void setup_base_frame(struct pxafb_info *fbi,
 static int setup_frame_dma(struct pxafb_info *fbi, int dma, int pal,
 			   unsigned long offset, size_t size);
 
+static int init_framebuffer_memory(void);
+
+static unsigned long video_mem_size;
+static unsigned long phys_addr_fbram;
+static unsigned long fb_virt_addr;
 static unsigned long video_mem_size = 0;
 
 static inline unsigned long
@@ -1702,20 +1715,55 @@ static const struct dev_pm_ops pxafb_pm_ops = {
 };
 #endif
 
+static int init_framebuffer_memory() {
+
+	pgprot_t prot_section;
+	struct vm_struct * vram;
+	pgd_t *pgd;
+	pmd_t *pmd;
+
+	vram=get_vm_area((SZ_1M * 2), VM_IOREMAP);
+	if (vram == NULL)
+		return -1;
+	fb_virt_addr = (unsigned long) vram->addr;
+	fb_virt_addr &= (~SZ_1M << 20); /*align to 1MiB boundary. this is too crude... */
+
+	prot_section = 0xC46; /* user accessible, uncached, buffered */
+	phys_addr_fbram = 0xA3E00000;
+	pgd=pgd_offset_k(fb_virt_addr);
+	pmd=pmd_offset(pgd, (fb_virt_addr));
+	pmd[0] = phys_addr_fbram | prot_section;
+	pmd[1] = INTERNAL_SRAM_START | prot_section;
+	flush_tlb_all();
+	flush_cache_all();
+	return fb_virt_addr;
+}
+
 static int __devinit pxafb_init_video_memory(struct pxafb_info *fbi)
 {
-	int size = PAGE_ALIGN(fbi->video_mem_size);
 
-	fbi->video_mem = alloc_pages_exact(size, GFP_KERNEL | __GFP_ZERO);
+		int size;
+
+	fb_virt_addr = init_framebuffer_memory();
+	size = PAGE_ALIGN(fbi->video_mem_size);
+	if (fb_virt_addr != -1) {
+		fbi->video_mem = (void *)fb_virt_addr;
+		fbi->video_mem_phys = 0xA3E00000;
+	}
+	else {
+		printk(KERN_ALERT "PXAFB SRAM/RAM video ram allocation failed!\n");
+		fbi->video_mem = alloc_pages_exact(size, GFP_KERNEL | __GFP_ZERO);
+		fbi->video_mem_phys = virt_to_phys(fbi->video_mem);
+	}
+
 	if (fbi->video_mem == NULL)
-		return -ENOMEM;
+	return -ENOMEM;
 
-	fbi->video_mem_phys = virt_to_phys(fbi->video_mem);
 	fbi->video_mem_size = size;
 
-	fbi->fb.fix.smem_start	= fbi->video_mem_phys;
-	fbi->fb.fix.smem_len	= fbi->video_mem_size;
-	fbi->fb.screen_base	= fbi->video_mem;
+	fbi->fb.fix.smem_start = fbi->video_mem_phys;
+	fbi->fb.fix.smem_len = fbi->video_mem_size;
+	fbi->fb.screen_base = fbi->video_mem;
 
 	return fbi->video_mem ? 0 : -ENOMEM;
 }
diff --git a/drivers/video/pxafb.h b/drivers/video/pxafb.h
index 26ba9fa..189be31 100644
--- a/drivers/video/pxafb.h
+++ b/drivers/video/pxafb.h
@@ -197,4 +197,7 @@ struct pxafb_info {
 #define MAX_XRES	1024
 #define MAX_YRES	1024
 
+#define INTERNAL_SRAM_START	0x5c000000
+#define INTERNAL_SRAM_SIZE	0x00040000
+
 #endif /* __PXAFB_H__ */
diff --git a/include/linux/fb.h b/include/linux/fb.h
index 1d6836c..07a9edb 100644
--- a/include/linux/fb.h
+++ b/include/linux/fb.h
@@ -38,6 +38,8 @@
 #define FBIOGET_HWCINFO         0x4616
 #define FBIOPUT_MODEINFO        0x4617
 #define FBIOGET_DISPINFO        0x4618
+#define FBIOGET_VRAM_START_ADDRESS 0x4619
+#define FBIOGET_VRAM_END_ADDRESS 0x4620
 #define FBIO_WAITFORVSYNC	_IOW('F', 0x20, __u32)
 
 #define FB_TYPE_PACKED_PIXELS		0	/* Packed Pixels	*/
-- 
1.7.4.1

