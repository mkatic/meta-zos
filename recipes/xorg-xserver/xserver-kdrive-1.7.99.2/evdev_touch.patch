diff --git a/hw/kdrive/linux/evdev.c b/hw/kdrive/linux/evdev.c
index 096a2dd..bb8d735 100644
--- a/hw/kdrive/linux/evdev.c
+++ b/hw/kdrive/linux/evdev.c
@@ -60,39 +60,16 @@ typedef struct _kevdev {
     int                     fd;
 } Kevdev;
 
-static void
-EvdevPtrBtn (KdPointerInfo    *pi, struct input_event *ev)
-{
-    int flags = KD_MOUSE_DELTA | pi->buttonState;
+struct ts_sample {
+	int		x;
+	int		y;
+	int 	lastx;
+	int		lasty;
+	unsigned int	pressure;
+	struct timeval	tv;
+};
 
-    if (ev->code >= BTN_MOUSE && ev->code < BTN_JOYSTICK) {
-        switch (ev->code) {
-        case BTN_LEFT:
-            if (ev->value == 1)
-                flags |= KD_BUTTON_1;
-	    else
-                flags &= ~KD_BUTTON_1;
-             break;
-        case BTN_MIDDLE:
-            if (ev->value == 1)
-                flags |= KD_BUTTON_2;
-	    else
-		flags &= ~KD_BUTTON_2;
-            break;
-        case BTN_RIGHT:
-            if (ev->value == 1)
-                flags |= KD_BUTTON_3;
-	    else
-		flags &= ~KD_BUTTON_3;
-            break;
-        default:
-            /* Unknow button */
-            break;
-        }
 
-        KdEnqueuePointerEvent (pi, flags, 0, 0, 0);
-    }
-}
 static void
 EvdevPtrMotion (KdPointerInfo    *pi, struct input_event *ev)
 {
@@ -161,6 +138,10 @@ EvdevPtrRead (int evdevPort, void *closure)
     int                        i;
     struct input_event        events[NUM_EVENTS];
     int                        n;
+    long x = 0, y = 0;
+    unsigned long flags;
+    int a[7]={37, -8961, 33606232, 12473, 252, -3803356, 65536};
+    struct ts_sample ts_event;
 
     n = read (evdevPort, &events, NUM_EVENTS * sizeof (struct input_event));
     if (n <= 0) {
@@ -172,22 +153,60 @@ EvdevPtrRead (int evdevPort, void *closure)
     n /= sizeof (struct input_event);
     for (i = 0; i < n; i++)
     {
-        switch (events[i].type) {
-        case EV_SYN:
-            break;
-        case EV_KEY:
-            EvdevPtrBtn (pi, &events[i]);
-            break;
-        case EV_REL:
-            ke->rel[events[i].code] += events[i].value;
-            EvdevPtrMotion (pi, &events[i]);
-            break;
-        case EV_ABS:
-            ke->abs[events[i].code] = events[i].value;
-            EvdevPtrMotion (pi, &events[i]);
-            break;
-        }
-    }
+    	switch (events[i].type) {
+    				case EV_KEY:
+    					switch (events[i].code) {
+    					case BTN_TOUCH:
+    						if (events[i].value == 0) {
+    							/* pen up */
+    							ts_event.x = 0;
+    							ts_event.y = 0;
+    							ts_event.pressure = 0;
+    							ts_event.tv = events[i].time;
+    						}
+    						break;
+    					}
+    					break;
+    				case EV_SYN: /* Fill out a new complete event */
+
+    					if (ts_event.pressure) {
+
+    						flags = KD_BUTTON_1;
+
+        					x = ( a[2] + a[0]*ts_event.x + a[1]*ts_event.y ) / a[6];
+        					y = ( a[5] + a[3]*ts_event.x + a[4]*ts_event.y ) / a[6];
+
+    						KdEnqueuePointerEvent (pi, flags, x, y, ts_event.pressure);
+
+    						ts_event.lastx = x;
+    						ts_event.lasty = y;
+
+    					}
+    					else {
+
+    						flags = 0;
+							x = ts_event.lastx;
+							y = ts_event.lasty;
+
+    						KdEnqueuePointerEvent (pi, flags, x, y, ts_event.pressure);
+    					}
+
+    					break;
+    				case EV_ABS:
+    					switch (events[i].code) {
+    					case ABS_X:
+    						ts_event.x = events[i].value;
+    						break;
+    					case ABS_Y:
+    						ts_event.y = events[i].value;
+    						break;
+    					case ABS_PRESSURE:
+    						ts_event.pressure = events[i].value;
+    						break;
+    					}
+    					break;
+    				}
+    			}
 }
 
 char *kdefaultEvdev[] =  {
